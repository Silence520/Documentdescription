http协议需要补充一下的，面试官问你不得问你http来源之类的，直接就问你特点，这点你的知悉，还有就是三次握手，四次挥手别忘了。

http协议：超文本传输协议

特性：

1.无状态

2.持久连接

3.支持客户、服务器模式，简单快速，还有就是灵活

影响http的因素：

1.带宽

2.延迟 浏览器阻塞 一个浏览器对于同一个域名只能有四个链接（不同的浏览器不一样），如果超过了会被阻塞

3.dns 查询：浏览器建立链接是需要知道服务器IP地址的，DNS用来将域名解析为ip地址，可以通过刷新DNS缓存来加快速度

4.建立链接：http协议是基于TCP的，即使网络，浏览器再快也得进行三次握手，在高延迟的网络环境下影响比较明显

http 缺陷

1. 耗时：每次传输都要建立链接

2.不安全：http是明文传输的，只要在路由器或者交换机上面截取，所有东西（账户，密码）都是可见的、采用wireshark抓包

3.header内容太大：通常用户的请求header变化的概率很小，但是每次请求都要携带大量的header信息，导致传输成本增加

4.keepalive压力太大：持久连接虽然有优点，但同时也会给服务器造成大量的性能压力，特别是传输图片的时候



HTTPS：由于http的不安全性，产生了https

HTTPS才用SSL最后演化为TLS（安全传输层协议）



SPDY：综合了HTTPS和HTTP两者优点

1. 降低延迟：才用多路复用降低延迟

2.请求优先级：给request设置优先级，这样子重要的请求就会优先得到响应

3.头部压缩

4.服务端推送 ：比如我要请求一个style.css的文件，在客户端接收到这个数据的同时，服务器会把style.js文件推送给客户端，在客户端再来请求这个文件的时候，就可以直接从缓存中去取了



HTTP2.0

特性：

1.二进制帧

2.多路复用：所有的请求通过一个tcp连接完成

3.流量控制 优先级设置

4.服务器推送

5.首部压缩



tcp请求的三次握手：

1. 客户端向服务器发起SYN报文：嘿，哥们，在不，我要和你通信一下？

2.服务器接收到请求报文之后，回复SYN+ACK报文，并未这次连接分配资源：嘿，小弟弟，我收到你的请求了，我这边ok了，

3.客户端接收到服务器的确认报文之后再一次发送ACK报文给服务器：嘿哥们，我也准备好了；

ok  这就是三次握手

tcp断开的四次挥手

1.客户端发起中断请求，发送FIN报文给服务器：”嘿，哥们，我客户端没有数据给你了，要断开哦“

2.服务器接收到客户端请求，立即发送ACK确认报文：“嘿，小弟弟，你的请求我收到了，但是我还没准备好，等我一下”

3.服务器确认数据发送完毕之后，再次发送FIN报文给客户端：“嘿，小弟弟，我这边数据发送完毕了，准备好关闭了哦”

4.客户端接收到服务器的关闭通知之后，发送ACK确认报文：“嘿，哥们，你关闭吧”

这样子之后，服务端收到确认报文，直接断开连接，客户端等待2ms之后依然没有收到回复，证明服务端已经关闭了，ok，这样子客户端也关闭了





node那个章节：

常用的node控制同异步的手段：

原始jquery时代：deferred   Q.js Wind Bigpipe

然后es6的时代：generator 和yield next

然后promise then

然后es7的时代：async await





垃圾回收GC包括三个主要步骤

1.枚举根节点的引用

2.发现并标记活对象

3.垃圾内存清理



分代回收在V8中分为 Scavenge mark-sweep

scavenge：当分配指针达到了新生区的末尾，就会有一次清理

这个算法的大概意思是：新生区被分为两个等大的区（from和to），绝大多数内存的分配都会出现在from区（但是某些可执行的代码对象是分配在老生区的），当from区耗尽时，我们交换from和to，然后将from区中活跃的对象复制到to区或者晋升到老生区中，其中标记的过程时深度优先搜索！

新生代被回收过一次 发现to的使用空间超过25%晋升到老生代

缺点：scavenge算法对于快速回收和紧缩内存效果很好，但是对于大片内存则消耗过大，频繁的拷贝对于cpu是不可承受之重，老生区包含有上百M的数据，对于这种区域我们采用标记-清除，标记-压缩算法

mark-sweep  mark-compact

清理算法很简单：遍历页的位图，搜索连续的死对象释放，时间久了就会形成内存碎片

紧缩算法：尝试将对象从碎片页中迁移整合在一起，来释放内存，这些对象会被迁移到另外的页上，因为也可能会重新分配一些页面。alinode对此策略进行了优化







—webpack性能优化：

经历多个web项目实战之后，归纳webpack缺陷

1.代码全量构建速度过慢，即使是很小的改动，也要等待很长时间才能查看更新与编译之后的结果（引入HMR热更新之后有明显的改进）

2.随着项目业务的复杂度增加，工程模块的体积也会急剧增大，构建后的模块通常要以M为单位计算

3.多个项目之间公用基础资源存在重复打包，基础库代码复用率不算太高

4.node的单进程实现在CPU计算型的loader中表现不佳



webpack 分析工具：webpack-bundle-analyzer：自动帮你计算出各个模块在你的项目中的依赖和分部情况



优化建议：

1.利用dllPlugin 和dllReferencePlugin 预编译资源模块：因为npm包不会进行修改，所以构建的时候没必要每次都去解析

2.使用happypack 加速代码构建--开启多线程：happypack在编译过程中除了利用多进程的模式加速编译，还同时开启了cache计算，能充分利用缓存读取构建文件

3.增加uglify，在构建的时候发现，webpack build走到80%左右的时候，会发生很长时间的停滞，经测试对比发现正是uglifyJS在对我们output中的bundle部门进行压缩导致耗时过长，针对这块儿可以使用webpack-uglify-parallel 来提成压缩速度（才用多核并行压缩的方式）

4.配置external +libraryTarget，把各种库的源码external一下，使用了之后，webpack就不会去打包，加快速度

5.生成输出的文件要走chunkhash 而不用trunk

6.激活代码热更新功能HMR




1.浏览器缓存专题 缓存原理

2.local seion扩容

2.前端跨域方式以及原理

3.前端工程化特点，以及为啥要工程化

4.上线项目如何监控，确保自己项目稳健

5.你认为完美的一个项目需要哪些特点，阐述一下？每个特点需要什么技术去实现？

6.比较vue react angular  优缺点？项目选型的时候如何抉择？

7.还有经典的post和get优缺点，事件冒泡机制，如何制止，如何传递的？继承实现方式？如何实现函数重载？

8.算法集锦—特别是快速排序 要死记

9.前端安全如何保证？你有什么认识？对渗透有了解吗

10.函数式编程 你的认识是怎么样的？

11.前端设计模式，对于常用的单例模式 工厂模式  代理模式 命令模式 责任链模式 这几个都得熟悉了解使用场景

12.自己做一个代码集锦，收集自己认为优秀的代码，没事儿拿出来翻翻

13.测试这个一定要做细点，真的是面试加分项，测试工具比较，为啥是这个测试工具来干这活？测试流程

14.项目上线流程是咋样的？你简单阐述一下？

15.你把前端项目性能优化总结一下：结合输入url发生了什么，这个步骤来联想，比如进行了dns解析，优化dns可以进行预解析加快速度等。。。。联想下去。。。到后段node优化。。。

 针对html优化：google 的amp

针对img的优化：压缩雪碧图等

针对js的优化：优化，公共代码提取等

针对cookie的优化：静态资源配置为不带cookie，因为浪费等

针对缓存的优化：把代码进行拆分，业务和非业务，变量和非变量，不太重要且不是很频繁的，比如验证类，工具类可以进行缓存的

针对页面渲染的优化：重绘重排，如何避免，如何查看，工具是啥

如果让你做一个前端页面性能监控，你如何构思？如何做？原理是啥？

16.谈谈对前端新技术的认知？PWA dart ,webAssemly等等 准备几个

目前就这些吧，你有空再收集收集吧！







